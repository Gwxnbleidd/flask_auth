## Задание 1

1. Предложите свою логику API авторизации 

2. Реализуете её с использованием flask (реализация базы данных - по желанию);

3. Также реализуете две "ручки" в веб-приложении:

   - /login (которая возвращает общую страницу авторизации, как разметку, в которую будет подгружаться форма авторизации);
   - /get/login/content (которая вернёт исключительно форму авторизации, для указанной страницы выше. Вызвав этот метод на странице /login, необходимо получить и отрисовать форму авторизации).

4. Дополнительно реализуйте функцию-пустышку (название и путь данной "ручки" придумайте сами), которая возвращает авторизованному пользователю собранный вами json-объект, допустим, подготовленный список объектов для отображения на сайте.

### Итог

Чтобы запустить приложение нужно находясь в ./app прописать в консоли pip install -r requirements.txt и python main.py (python3 main.py)<br>

В базе данных всего два пользователя: <br>
* login: admin, password: 1234
* login: user, password: 4321

Я реализовал авторизацию на основе jwt токена с передачей его в cookie.<br>
Этот способ хорош тем, что он достаточно прост, не нужно вручную передавать в заголовках токен, также не нужно использовать javascript, все пишется на питоне. Jwt удобен тем, что токен хранится не на сервере, а у пользователя.
Также при этом методе отпадает необходимость в сессиях.И токен недоступен JavaScript внутри браузера.<br>

Я еще не писал проекты на Flask, но мне кажется, что я в состоянии быстро освоить этот инструмент.<br>
Я знаю, что у flask есть специальные методы для работы с jwt, даже для получения из cookies, но у меня не получилось настроить этот способ, поэтому я написал свои методы для работы с jwt, а также свой дескриптор для проверки доступа.<br>

Я сделал 4 эндпоинта: /login и /get/login/content, которые выполняют все точно как в задании, /protected - доступен только авторизированным пользователям, он нужен, чтобы показать, что авторизация работает, и get_data - возвращает json объект.<br>
Я сделал base.html и от него наследовал остальные страницы. Этот метод удобен тем, что мы не копируем один и тот же код много раз. И при добавлении новых html документов, они тоже будут наследоваться от base.html. <br>

Для работы с бд я использовал postgreSQL и SQLalchemy. Просто хотел показать, что умею с ними работать.<br>
Я знаю, что так не делают, но на всякий случай я добавил в репозиторий скрытые файлы.<br>


## Задание 2
1. Вам необходимо вывести/вернуть список всех заказчиков (id, локальное имя, тип, актуального руководителя) отсортировав результаты по возрастанию по полям:
   - типу лица;
   - в алфавитном порядке по локальным именам;
   - только рабочих заказчиков.

```sql
select t.id, t.internal_name, t.person, t.head
from
(SELECT 
  c.id, 
  c.internal_name, 
  c.person, 
  key as head, 
  value :: jsonb -> 'up_to_date_of' as date_of
FROM 
  counterparties.counterparties c
JOIN
  jsonb_each_text(c.heads) AS heads_items ON true 
ORDER BY
  c.person , c.internal_name ) as t
where length(text(t.date_of)) < 3
```

2. Необходимо вывести/вернуть список банков определенного заказчика (по его уникальному полю)

Вернем заказчика с id = 4 (тот, у которого два банка): <br>

``` sql

select t.key as banks  
from jsonb_each (
(select c.banks as banks  
 FROM counterparties.counterparties AS c
 where id = '4')) as t

```
### Итог
Было непросто, никогда еще не работал с json в postreSQL. Первый запрос скорее всего можно написать куда лучше,но сегодня у меня получилось только так.

## Задание 3
Упаковать вами написанный проект в docker/docker-compose, при необходимости добавить окружение.<br>
Чтобы запустить docker-compose, нужно в терминале написать docker-compose up. (в стартовой директории)<br>
